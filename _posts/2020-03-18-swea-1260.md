---
title: "SWEA 1260. 화학물질2 "
excerpt: "SWEA 1260. 문제 풀이"

toc: true
toc_sticky: true

categories:
  - 알고리즘
tags:
  - DP
last_modified_at: 2020-03-19T01:49:00
---

이전에 포스트한 [[SWEA 1258. 행렬찾기][link1]], [[SWEA 1259. 금속막대][link2]] 두 문제와 `DP`를 응용한 문제이다. 

# 1. 문제출처
---
[[{{page.title}}](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV18OR16IuUCFAZN&categoryId=AV18OR16IuUCFAZN&categoryType=CODE "바로가기"){: target="_blank"}]

# 2. 문제풀이
---

풀이순서는 다음과 같다.

 1. 문제에서 영역의 `행`과 `열`을 찾는다.
	- 관련 POST : [SWEA 1258. 행렬찾기 풀이][link4]

 2. 행렬곱이 가능하게 끔 `정렬`한다.
	- 관련 POST : [SWEA 1259. 금속막대 풀이][link3]

 3. 행렬곱을 수행하였을 때 곱셈연산 수가 최소가되는 값을 구한다.
	- 곱하는 **순서**에 따라 **곱셈연산의 수**가 달라진다!

## 2-1. 행렬곱

문제를 풀기에 앞서 행렬곱의 특성에 대해서 알아보자.

 `A(2,3) X B(3,4)` 수행 시 몇 번의 곱셈 연산이 일어날까?

`A행렬의 행`과 `B행렬의 열`을 곱하는 연산(=3번)이 `A의 행`만큼(=2번) * `B의 열`만큼(=4번) 일어난다.

즉, `3 * 2 * 4 = 24번`의 곱셈연산이 일어난다.

	A(2,3) X B(3,4) 에서 곱셈 연산의 수는

	의 행 수 * A의 열 수(=B의 행 수) * B의 열 수

## 2-2. 곱셈연산이 최소가 되려면




# 3. 코드

```c++
#include <iostream>
#include <deque>
#define MAX 2000000000
using namespace std;

struct status {
	int width;
	int height;
};

int map[100][100], map_size;
int dp[30][30];

deque<status> storage, connect;

int min(int a, int b) {
	if (a < b)return a;
	else return b;
}

// 행렬을 행렬곱이 가능하게 연결해주는 함수
void get_storage(int y, int x) {

	int width = 0, height = 0;

	while (x + width < map_size && map[y][x + width] != 0) width++;
	while (y + height < map_size && map[y + height][x] != 0) height++;

	for (int i = y; i < y + height; i++) {
		for (int j = x; j < x + width; j++) {
			map[i][j] = 0;
		}
	}

	storage.push_back({ width,height });
}

// 주어진 map에서 용기들의 width, height를 구하는 함수
void connect_matrix() {

	connect.push_back(storage.front());
	storage.pop_front();

	while (!storage.empty()) {

		for (int i = 0; i < storage.size(); i++) {

			if (connect.back().width == storage[i].height) {

				connect.push_back(storage[i]);
				storage.erase(storage.begin() + i);
				break;
			}

			else if (connect.front().height == storage[i].width) {

				connect.push_front(storage[i]);
				storage.erase(storage.begin() + i);
				break;
			}
		}
	}
}

// [p1 ~ p2]까지 행렬곱을 수행하였을 때 최소 곱셈 수를 리턴한다.
int solve(int p1, int p2) {

	if (dp[p1][p2] != -1)return dp[p1][p2];
	else {

		int result_min = MAX;

		for (int i = p1; i < p2; i++) {
			result_min = min(result_min, solve(p1, i) + solve(i + 1, p2) + (connect[p1].height * connect[i].width * connect[p2].width));
		}

		return dp[p1][p2] = result_min;
	}
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	int test;
	cin >> test;
	for (int t = 1; t <= test; t++) {

		// 입력
		cin >> map_size;

		for (int i = 0; i < map_size; i++) {
			for (int j = 0; j < map_size; j++) {
				cin >> map[i][j];
			}
		}

		// 초기화
		storage.clear();
		connect.clear();

		// 용기 구하기
		for (int i = 0; i < map_size; i++) {
			for (int j = 0; j < map_size; j++) {
				if (map[i][j]) {
					get_storage(i, j);
				}
			}
		}

		// 용기 행렬곱 가능하게 배치하기
		connect_matrix();

		// dp 초기화
		for (int i = 0; i < connect.size(); i++) {
			for (int j = 0; j < connect.size(); j++) {
				if (i == j)dp[i][j] = 0;
				else dp[i][j] = -1;
			}
		}

		// n번째 행렬곱 구하기
		solve(0, connect.size() - 1);

		// 출력
		cout << "#" << t << " " << dp[0][connect.size()-1] << endl;
	}
	return 0;
}
```

[link1]: https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV18LoAqItcCFAZN&categoryId=AV18LoAqItcCFAZN&categoryType=CODE "Software Expert Academy 바로가기"

[link2]: https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV18NaZqIt8CFAZN&categoryId=AV18NaZqIt8CFAZN&categoryType=CODE "Software Expert Academy 바로가기"

[link3]: https://skud8049.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/swea-1259/ "SWEA 1259. 금속막대"

[link4]: https://skud8049.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/swea-1258/ "SWEA 1258. 행렬 찾기"